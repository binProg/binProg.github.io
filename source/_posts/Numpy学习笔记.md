---
title: Numpy学习笔记
date: 2021-12-27 10:06:58
tags: Numpy
mathjax: true
---



# Numpy学习笔记

## 1. 生成Numpy数组

### 1.1 从已有数据中创建数组

- 将列表转换成ndarray

```python
import numpy as np
lst1 = [3.14, 2.17, 1, 2, 3]
nd1 = np.array(lst1)
print(nd1)
print(type(nd1))
```

```
[3.14 2.17 1.   2.   3.  ]
<class 'numpy.ndarray'>
```

- 嵌套列表可以转换为多维ndarray

```python
lst2 = [lst1,[1,2,3,4,5]]
nd2 = np.array(lst2)
print(nd2)
print(type(nd2))
```

```
[[3.14 2.17 1.   2.   3.  ]
 [1.   2.   3.   4.   5.  ]]
<class 'numpy.ndarray'>
```

将上面列表转换为元组同样适用

### 1.2 利用random模块生成数据

> 在深度学习中，我们经常需要对一些参数进行初始化，因此为了更有效地训练模型，提高模型的性能，有些初始化还需要满足一定的条件，比如满足正态分布或者均匀分布等

- np.random.random: 生成0到1之间的随机数
- np.random.uniform: 生成均匀分布的随机数
- np.random.randn: 生成标准正太的随机数
- np.random.randint: 生成随机的整数
- np.random.normal: 生成正太分布
- np.random.shuffle: 随机打乱顺序
- np.random.seed: 设置随机种子数
- random_sample: 生成随机的浮点数

```python
nd3 = np.random.random([3,3])
print(nd3)
```

```
[[0.31219192 0.28280657 0.69562286]
 [0.29565657 0.06571726 0.89714922]
 [0.22436833 0.03590968 0.86430496]]
```

```python
print("nd3的形状为：",nd3.shape)
>>> nd3的形状为： (3, 3)
```

为了每次生成同一份数据，可以指定一个随机种子，使用shuffle函数打乱生成的随机数

```python
np.random.seed(123)
nd4 = np.random.randn(2,3)
print(nd4)
np.random.shuffle(nd4)
print("随机打乱后数据:")
print(nd4)
print(type(nd4))
```

```
[[-1.0856306   0.99734545  0.2829785 ]
 [-1.50629471 -0.57860025  1.65143654]]
随机打乱后数据:
[[-1.50629471 -0.57860025  1.65143654]
 [-1.0856306   0.99734545  0.2829785 ]]
<class 'numpy.ndarray'>
```

### 1.3 创建特定形状的一维数组

> 参数初始化时，有时需要生成一些特殊的矩阵，如全是0或全是1的数组或矩阵，这时，可以利用`np.zeros`，`np.ones`,`np.diag`来实现

![IMG_0360.PNG](attachment:IMG_0360.PNG)

```python
# 生成全是0的3*3的矩阵
nd5 = np.zeros([3,3])
# 生成nd5形状一样的全是0的矩阵
nd6 = np.zeros_like(nd5)
# 生成全是1的3*3的矩阵
nd7 = np.ones([3,3])
# 生成3阶单位矩阵
nd8 = np.eye(3)
# 生成3阶对角矩阵
nd9 = np.diag([1,2,3])
```

```python
print(nd5)
print(nd6)
print(nd7)
print(nd8)
print(nd9)
```

```
[[0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]]
[[0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]]
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
[[1 0 0]
 [0 2 0]
 [0 0 3]]
```

有时，需要把生成的矩阵暂时保存起来以备后续使用

```python
nd10 = np.random.random([5,5])
np.savetxt(X=nd10,fname="./test1.txt")
nd11 = np.loadtxt('./test1.txt')
print(nd11)
```

```
[[0.41092437 0.5796943  0.13995076 0.40101756 0.62731701]
 [0.32415089 0.24475928 0.69475518 0.5939024  0.63179202]
 [0.44025718 0.08372648 0.71233018 0.42786349 0.2977805 ]
 [0.49208478 0.74029639 0.35772892 0.41720995 0.65472131]
 [0.37380143 0.23451288 0.98799529 0.76599595 0.77700444]]
```

### 1.4 利用arange/linspace函数生成数组

```python
print(np.arange(10)) # start=0, stop=10, step=1
```

```
[0 1 2 3 4 5 6 7 8 9]
```



```python
print(np.arange(0,10))
```

```
[0 1 2 3 4 5 6 7 8 9]
```



```python
print(np.arange(1,4,0.5))
```

```
[1.  1.5 2.  2.5 3.  3.5]
```



```python
print(np.arange(9,-1,-1))
```

```
[9 8 7 6 5 4 3 2 1 0]
```

linspace可以根据输入的指定数据范围以及等分数量，自动生成一个线性等分向量

```python
print(np.linspace(0,1,10)) # 步长=(1-0)/9
```

```
[0.         0.11111111 0.22222222 0.33333333 0.44444444 0.55555556
 0.66666667 0.77777778 0.88888889 1.        ]
```



```python
print(np.linspace(0.1,1,10))
```

```
[0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]
```



```python
print(np.logspace(0,1,10))
```

```
[ 1.          1.29154967  1.66810054  2.15443469  2.7825594   3.59381366
  4.64158883  5.9948425   7.74263683 10.        ]
```

## 2. 获取元素

```python
import numpy as np
np.random.seed(2019)
nd12 = np.random.random([10])
print(">>>ndarray: \n",nd12)
# 获取指定位置的数据，获取第4个元素
print("\n>>>第4个元素: \n",nd12[3])
# 截取一段数据
print("\n>>>第4到第6个元素：",nd12[3:6])
print("\n>>>截取固定间隔的数据：\n",nd12[1:6:2])
print("\n>>>倒序取数: \n",nd12[::-2])
print("\n>>>截取一个多维数组的一个区域内的数据：")
nd13 = np.arange(25).reshape([5,5])
print(nd13[1:3,1:3])
print("\n>>>截取一个多维数组中，数值在一个值域之内的数据：")
print(nd13[(nd13>3)&(nd13<10)])
print("\n>>>截取多维数组中，指定的列，如读取第2，3列：")
print(nd13[:,1:3])
```

```
>>>ndarray: 
 [0.90348221 0.39308051 0.62396996 0.6378774  0.88049907 0.29917202
 0.70219827 0.90320616 0.88138193 0.4057498 ]

>>>第4个元素: 
 0.6378774010222266

>>>第4到第6个元素： [0.6378774  0.88049907 0.29917202]

>>>截取固定间隔的数据：
 [0.39308051 0.6378774  0.29917202]

>>>倒序取数: 
 [0.4057498  0.90320616 0.29917202 0.6378774  0.39308051]

>>>截取一个多维数组的一个区域内的数据：
[[ 6  7]
 [11 12]]

>>>截取一个多维数组中，数值在一个值域之内的数据：
[4 5 6 7 8 9]

>>>截取多维数组中，指定的列，如读取第2，3列：
[[ 1  2]
 [ 6  7]
 [11 12]
 [16 17]
 [21 22]]

```

> 获取ndarray中的部分元素，除了通过指定的索引标签来实现外，还可以通过使用一些函数来实现，如通过`random.choice`函数从指定的样本中随机抽取数据

```python
import numpy as np
from numpy import random as nr
a = np.arange(1,25,dtype=float)
print(">>> a: \n",a)
c1 = nr.choice(a, size=(3,4)) #size指定输出数组形状
c2 = nr.choice(a, size=(3,4), replace=False) # replace默认为Ture，即可重复抽取
c3 = nr.choice(a, size=(3,4), p=a/np.sum(a)) # p为每个元素对应的抽取概率，缺省为每个元素被抽取的概率相同
print("\n>>> 随机可重复抽取：\n",c1)
print("\n>>> 随机不可重复抽取：\n",c2)
print("\n>>> 随机但按制度概率抽取：\n",c3)

```

```
>>> a: 
 [ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10. 11. 12. 13. 14. 15. 16. 17. 18.
 19. 20. 21. 22. 23. 24.]

>>> 随机可重复抽取：
 [[16. 15. 18. 18.]
 [14. 18. 18. 14.]
 [23. 16. 13.  3.]]

>>> 随机不可重复抽取：
 [[ 6. 14.  7.  4.]
 [19.  2.  3. 16.]
 [12. 10.  9. 20.]]

>>> 随机但按制度概率抽取：
 [[24. 15. 23. 16.]
 [ 9.  9. 17. 19.]
 [23. 13. 12. 17.]]


```

## 3.Numpy的算术运算

### 3.1 对应元素相乘（Element-Wise Product)

对应元素相乘是矩阵中对应位置元素的乘积<br>
`np.multiply`函数用于数组或矩阵对应元素相乘，输出与相乘数组或矩阵的大小一致

```python
import numpy as np
A = np.array([[1,2],[-1,4]])
B = np.array([[2,0],[3,4]])
print(">>> A*B: ")
print(A*B)
print("\n>>> np.multiply: ")
print(np.multiply(A,B))
# ndarray与标量相乘，广播机制
print("\n>>> A*2.0:")
print(A*2.0)
print("\n>>> A/2.0:")
print(A/2.0)
```

```
>>> A*B: 
[[ 2  0]
 [-3 16]]

>>> np.multiply: 
[[ 2  0]
 [-3 16]]

>>> A*2.0:
[[ 2.  4.]
 [-2.  8.]]

>>> A/2.0:
[[ 0.5  1. ]
 [-0.5  2. ]]


```

**因此，推而广之，数组通过一些 激活函数 后，输出与输入形状一致**

```python
import numpy as np 
def softmoid(x):
    return 1/(1+np.exp(-x))
def relu(x):
    return np.maximum(0,x)
def softmax(x):
    return np.exp(x)/np.sum(np.exp(x))

X = np.random.rand(2,3)
print("输入参数X的形状：",X.shape)
print("激活函数softmoid输出形状：",softmoid(X).shape)
print("激活函数relu输出形状：",relu(X).shape)
print("激活函数softmax输出形状：",softmax(X).shape)
```

```
输入参数X的形状： (2, 3)
激活函数softmoid输出形状： (2, 3)
激活函数relu输出形状： (2, 3)
激活函数softmax输出形状： (2, 3)


```

### 3.2 点积运算

```python
X1 = np.array([[1,2],[3,4]])
X2 = np.array([[5,6,7],[8,9,10]])
X3 = np.dot(X1,X2)
print(X3)
```

```
[[21 24 27]
 [47 54 61]]


```

## 4. 数组变形

### 4.1 更改数组形状

#### reshape

```python
import numpy as np
arr = np.arange(10)
print("原始：")
print(arr)
# 将向量 arr 维度变换为2行5列
print("reshape：")
print(arr.reshape(2,5))
# 指定维度时，可以只指定行数或者列数，其它用-1代替
print(arr.reshape(5,-1))
print(arr.reshape(-1,5))
print(arr.reshape(3,6)) # ＥＲＲＯＲ：必须要符合原始向量的元素个数，即不能更改原始
```

```
原始：
[0 1 2 3 4 5 6 7 8 9]
reshape：
[[0 1 2 3 4]
 [5 6 7 8 9]]
[[0 1]
 [2 3]
 [4 5]
 [6 7]
 [8 9]]
[[0 1 2 3 4]
 [5 6 7 8 9]]


```

```
---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

<ipython-input-7-1df85e490da8> in <module>
      9 print(arr.reshape(5,-1))
     10 print(arr.reshape(-1,5))
---> 11 print(arr.reshape(3,6))
ValueError: cannot reshape array of size 10 into shape (3,6)

```

#### resize

```python
import numpy as np
arr = np.arange(10)
print(arr)
# 将向量 arr 维度变换为2行5列
arr.resize(2,5)
print(arr)
arr.resize(3,6)# 更改了向量
print(arr)
```

```
[0 1 2 3 4 5 6 7 8 9]
[[0 1 2 3 4]
 [5 6 7 8 9]]
[[0 1 2 3 4 5]
 [6 7 8 9 0 0]
 [0 0 0 0 0 0]]

```

#### 向量转置（T）

```python
import numpy as np
arr = np.arange(12).reshape(3,4)
# 向量为3行4列
print(arr)
print(arr.T)
```

```
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
[[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]

```

#### ravel向量展平

```python
import numpy as np
arr = np.arange(6).reshape(2,-1)
print(arr)
print("按照列优先，展平")
print(arr.ravel('F'))
print("按照行优先，展平")
print(arr.ravel())
```

```
[[0 1 2]
 [3 4 5]]
按照列优先，展平
[0 3 1 4 2 5]
按照行优先，展平
[0 1 2 3 4 5]

```

#### flatten

flatten：把**矩阵**转换为**向量**，这种需求经常出现在**卷积网络**和**全连接层**之间

```python
import numpy as np
a = np.floor(10*np.random.random((3,4))) # np.floor(x)：返回小于等于x的最大整数
print(a)
print(a.flatten())
```

```
[[7. 4. 5. 1.]
 [3. 2. 2. 5.]
 [1. 7. 5. 5.]]
[7. 4. 5. 1. 3. 2. 2. 5. 1. 7. 5. 5.]


```

#### squeeze

squeeze：主要用来**降维**，把矩阵中含1的维度去掉。

```python
import numpy as np
arr = np.arange(3).reshape(3,1)
print(arr.shape)
print(arr.squeeze().shape)
arr1 = np.arange(6).reshape(3,1,2,1)
print(arr1.shape)
print(arr1.squeeze().shape)
```

```
(3, 1)
(3,)
(3, 1, 2, 1)
(3, 2)

```

#### transpose

对高维矩阵进行轴对换，在深度学习中经常使用，比如把图片中表示颜色顺序的RGB改成GBR

```python
import numpy as np
arr2 = np.arange(24).reshape(2,3,4)
print(arr2.shape)
print(arr2.transpose(1,2,0).shape)
```

```
(2, 3, 4)
(3, 4, 2)


```

### 4.2 合并数组

- append、concatenate、stack都有一个**axis**参数，用于控制数组的合并方式是**按行还是按列**
- append和concatenate的数组必须有**相同的行数或者列数**
- stack,hstack,dstack要求待合并的数组**必须具有相同的形状**

#### append

```python
# 合并一维数组：
import numpy as np
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
c = np.append(a, b)
print(c)
```

```
[1 2 3 4 5 6]

```



```python
# 合并多维数组：
import numpy as np
a = np.arange(4).reshape(2,2)
b = np.arange(4).reshape(2,2)
# 按行合并
c = np.append(a, b, axis=0)
print("按行合并后的结果：")
print(c)
print("按行合并后数据的维度：",c.shape)
# 按列合并
d = np.append(a, b, axis=1)
print("按列合并后的结果：")
print(d)
print("按列合并后数据的维度：",d.shape)
```

```
按行合并后的结果：
[[0 1]
 [2 3]
 [0 1]
 [2 3]]
按行合并后数据的维度： (4, 2)
按列合并后的结果：
[[0 1 0 1]
 [2 3 2 3]]
按列合并后数据的维度： (2, 4)


```

#### concatenate

沿指定轴连接数组或矩阵：

```python
import numpy as np
a = np.array([[1,2],[3,4]])
b = np.array([[5,6]])
c = np.concatenate((a,b), axis=0)
print(c)
d = np.concatenate((a,b.T), axis=1)
print(d)

```

```
[[1 2]
 [3 4]
 [5 6]]
[[1 2 5]
 [3 4 6]]


```

#### stack

按指定轴堆叠数组或矩阵

```python
import numpy as np
a = np.array([[1,2],[3,4]])
b = np.array([[5,6],[7,8]])
print(np.stack((a,b),axis=0))
```

```
[[[1 2]
  [3 4]]

 [[5 6]
  [7 8]]]

```

### 5. 批量处理

在深度学习中，源数据通常都比较大，为了充分利用GPU和Numpy的平行处理优势，往往采用批量处理方法**Mini-Batch**<br>
拆分大数据为多个batch的步骤如下：<br>

- 得到数据集
- 随机打乱数据
- 定义batch大小
- 批处理数据集

```python
import numpy as np
# 生成10000个形状为2*3的矩阵
data_train = np.random.randn(10000,2,3)
# data_train是一个三维矩阵，第一个维度是样本数，第2，3个维度是样本数量
print(data_train.shape)
#打乱这10000条数据
np.random.shuffle(data_train)
# 定义批量大小
batch_size = 100
# 进行批处理
for i in range(0, len(data_train), batch_size):
    x_batch_sum = np.sum(data_train[i:i+batch_size])
    print("第{}批次，该批次的数据之和：{}".format(i,x_batch_sum))
```

```
(10000, 2, 3)
第0批次，该批次的数据之和：55.435104077411005
第100批次，该批次的数据之和：-30.16163984034822
第200批次，该批次的数据之和：-16.005886476247337
第300批次，该批次的数据之和：26.243420914316697
第400批次，该批次的数据之和：54.09272512386492
第500批次，该批次的数据之和：10.666172638549797
第600批次，该批次的数据之和：-7.4524338126181195
第700批次，该批次的数据之和：16.35508797187559
第800批次，该批次的数据之和：-31.156485946418083
第900批次，该批次的数据之和：-30.958781413477553
第1000批次，该批次的数据之和：-17.74687318011051
第1100批次，该批次的数据之和：-13.155419825123367
第1200批次，该批次的数据之和：36.62068018330997
第1300批次，该批次的数据之和：-9.52610840971721
第1400批次，该批次的数据之和：40.124990215128086
第1500批次，该批次的数据之和：-8.641718267773296
第1600批次，该批次的数据之和：29.490956639761517
第1700批次，该批次的数据之和：-18.545788043979094
第1800批次，该批次的数据之和：6.016028361267317
第1900批次，该批次的数据之和：-18.466307499414476
第2000批次，该批次的数据之和：37.212642842831734
第2100批次，该批次的数据之和：3.2911450511959117
第2200批次，该批次的数据之和：-41.99494902396746
第2300批次，该批次的数据之和：1.2948216575668532
第2400批次，该批次的数据之和：-71.43580130811536
第2500批次，该批次的数据之和：17.87735900883432
第2600批次，该批次的数据之和：37.67664694792802
第2700批次，该批次的数据之和：-7.55997209759624
第2800批次，该批次的数据之和：30.914571710543747
第2900批次，该批次的数据之和：-10.18189132360644
第3000批次，该批次的数据之和：-30.671382196814438
第3100批次，该批次的数据之和：-0.23187480748789113
第3200批次，该批次的数据之和：12.554362924197958
第3300批次，该批次的数据之和：-53.21534337519745
第3400批次，该批次的数据之和：-26.583560593560733
第3500批次，该批次的数据之和：-23.963057796830483
第3600批次，该批次的数据之和：-20.135410853277417
第3700批次，该批次的数据之和：38.023911057082785
第3800批次，该批次的数据之和：-13.32064222612313
第3900批次，该批次的数据之和：-6.889328224640572
第4000批次，该批次的数据之和：-31.01990202931473
第4100批次，该批次的数据之和：-27.84137706109179
第4200批次，该批次的数据之和：33.49698637790293
第4300批次，该批次的数据之和：12.212554187171982
第4400批次，该批次的数据之和：3.512815856108185
第4500批次，该批次的数据之和：-4.260687424492915
第4600批次，该批次的数据之和：35.48174080841822
第4700批次，该批次的数据之和：47.11583122229985
第4800批次，该批次的数据之和：35.11652490662901
第4900批次，该批次的数据之和：6.923124673929591
第5000批次，该批次的数据之和：-0.9601519043571036
第5100批次，该批次的数据之和：31.40795018298309
第5200批次，该批次的数据之和：-14.370508039492375
第5300批次，该批次的数据之和：2.0080627697661484
第5400批次，该批次的数据之和：49.9423922559288
第5500批次，该批次的数据之和：1.5986276917534745
第5600批次，该批次的数据之和：-14.292559911652749
第5700批次，该批次的数据之和：9.269236636816146
第5800批次，该批次的数据之和：35.261939078135256
第5900批次，该批次的数据之和：21.40686158271405
第6000批次，该批次的数据之和：63.72421750904502
第6100批次，该批次的数据之和：-4.449162479660419
第6200批次，该批次的数据之和：-12.87971193486877
第6300批次，该批次的数据之和：16.739166846569468
第6400批次，该批次的数据之和：15.507139793752685
第6500批次，该批次的数据之和：28.237722121881088
第6600批次，该批次的数据之和：19.428664862631027
第6700批次，该批次的数据之和：15.736081688984164
第6800批次，该批次的数据之和：-12.159796741250288
第6900批次，该批次的数据之和：28.296243694838907
第7000批次，该批次的数据之和：7.500594716026612
第7100批次，该批次的数据之和：4.654555617783968
第7200批次，该批次的数据之和：-8.868369636944283
第7300批次，该批次的数据之和：-38.15820793655656
第7400批次，该批次的数据之和：18.964283594574983
第7500批次，该批次的数据之和：-11.955730060930211
第7600批次，该批次的数据之和：-2.8986304404518926
第7700批次，该批次的数据之和：35.34306520647606
第7800批次，该批次的数据之和：12.358253221555003
第7900批次，该批次的数据之和：-30.10571822052315
第8000批次，该批次的数据之和：-46.60238546662976
第8100批次，该批次的数据之和：-14.535660376705316
第8200批次，该批次的数据之和：-32.16956146044525
第8300批次，该批次的数据之和：22.891974055182587
第8400批次，该批次的数据之和：17.937267722718893
第8500批次，该批次的数据之和：-7.5960642210042195
第8600批次，该批次的数据之和：-23.25232489911175
第8700批次，该批次的数据之和：-1.0112532518592268
第8800批次，该批次的数据之和：-53.012638021916835
第8900批次，该批次的数据之和：43.233451389942886
第9000批次，该批次的数据之和：16.00328538980951
第9100批次，该批次的数据之和：52.78228888158892
第9200批次，该批次的数据之和：-21.00762549901342
第9300批次，该批次的数据之和：-21.380219319924976
第9400批次，该批次的数据之和：-25.89993133337054
第9500批次，该批次的数据之和：8.653750464608649
第9600批次，该批次的数据之和：-47.21038400234219
第9700批次，该批次的数据之和：25.37845335924261
第9800批次，该批次的数据之和：-14.943652726871015
第9900批次，该批次的数据之和：6.466367180724267


```

### 6. 通用函数

Numpy提供两种基本的对象，即**ndarray和ufunc对象**<br>
ufunc是一种能对数组中每个元素进行操作的函数<br>

#### Math与Numpy函数的对比

```python
import numpy as np
import math
import time
x = [i*0.001 for i in np.arange(1000000)]
start = time.clock()
for i, t in enumerate(x):
    x[i] = math.sin(t)
print("math.sin:", time.clock()-start)
x = [i*0.001 for i in np.arange(1000000)]
x = np.array(x)
start = time.clock()
np.sin(x) # numpy可以并行计算，不用循环
print("numpy.sin:",time.clock()-start)
```

```
math.sin: 0.5838227
numpy.sin: 0.032238599999999895


```

由此可见，numpy比math快10倍左右

#### 循环和向量运算比较

```python
import numpy as np
import time
x1 = np.random.rand(1000000)
x2 = np.random.rand(1000000)

## 使用循环计算向量的点积
tic = time.process_time() # 计算程序所用时间
dot = 0
for i in range(len(x1)):
    dot += x1[i]*x2[i]
toc = time.process_time()
print("dot = "+str(dot)+"\nfor loop----- Computation time = "+str(1000*(toc-tic))+"ms")
##使用numpy函数求点积
tic = time.process_time()
dot = 0
dot = np.dot(x1,x2)
toc = time.process_time()
print("dot = "+str(dot)+"\nvector version----- Compution time = "+str(1000*(toc-tic))+"ms")
```

```
dot = 249573.00014043407
for loop----- Computation time = 890.625ms
dot = 249573.0001404432
vector version----- Compution time = 31.25ms


```

在深度学习算法中，一般都使用向量化矩阵进行运算

### 7. 广播机制

Numpy的ufunc中要求输入数组是一致的,当数组的**shape不相等**时，则会使用**广播机制**

```python
import numpy as np 
A = np.arange(0, 40, 10).reshape(4,1)
B = np.arange(0, 3)
print("A矩阵的形状：{}，B矩阵的形状：{}".format(A.shape, B.shape))
C = A+B
print("C矩阵的形状：{}".format(C.shape))
print(C)
```

```
A矩阵的形状：(4, 1)，B矩阵的形状：(3,)
C矩阵的形状：(4, 3)
[[ 0  1  2]
 [10 11 12]
 [20 21 22]
 [30 31 32]]


```

广播机制的生效规则：

- 所有输入数组都向其中shape最长的数组看齐，不足的部分通过在前面补1
- 输出数组的shape是输入数组shape的各个轴上的最大值
- 若输入数组的某个轴和输出数组的某个轴的长度相同或，某个轴的长度为1时，这个数组能被用来计算，否则出错
- 当输入数组的某个轴的长度为1时，沿此轴运算时都用此轴上的第一组值